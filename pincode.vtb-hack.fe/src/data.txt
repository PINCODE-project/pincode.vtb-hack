<table class="wrapped confluenceTable"><thead class=""><tr class=""><th class="confluenceTh"><strong>Правило</strong><button class="synchrony-exclude confluenceTableAction sortBtn" title="Сортировать столбец" contenteditable="false"><svg width="8" height="12" viewBox="0 0 8 12" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
    <path d="M3.58266 0.632493C3.78028 0.332989 4.21972 0.332989 4.41734 0.632494L6.95249 4.47463C7.17184 4.80706 6.93342 5.25 6.53515 5.25H1.46485C1.06657 5.25 0.828165 4.80706 1.04751 4.47463L3.58266 0.632493Z"></path>
    <path d="M4.41734 11.3675C4.21972 11.667 3.78028 11.667 3.58266 11.3675L1.04751 7.52537C0.828165 7.19294 1.06658 6.75 1.46485 6.75L6.53515 6.75C6.93343 6.75 7.17184 7.19294 6.95249 7.52537L4.41734 11.3675Z"></path>
</svg>
</button></th><th class="confluenceTh"><strong>Описание проблемы</strong></th><th class="confluenceTh"><strong>Рекомендация</strong></th></tr></thead><tbody class=""><tr class=""><td class="confluenceTd">SeqScanOnLargeTable</td><td class="confluenceTd">Последовательное сканирование большой таблицы '{0}' (PlanRows={1}) может приводить к высоким затратам ввода-вывода и замедлению выполнения.</td><td class="confluenceTd">Создайте индекс по фильтруемым колонкам или рассмотрите партиционирование таблицы.</td></tr><tr class=""><td class="confluenceTd">NestedLoopOnLargeTables</td><td class="confluenceTd">Nested Loop Join между большими таблицами (PlanRows={0}) крайне неэффективен и может вызвать экспоненциальный рост времени выполнения.</td><td class="confluenceTd">Замените Nested Loop на Hash Join или Merge Join при работе с большими таблицами.</td></tr><tr class=""><td class="confluenceTd">MisestimatedRows</td><td class="confluenceTd">Сильное расхождение между фактическим количеством строк ({0}) и оценкой планировщика ({1}) в таблице '{2}' указывает на неточные статистики.</td><td class="confluenceTd">Запустите ANALYZE для актуализации статистик; при необходимости используйте CREATE STATISTICS для зависимых колонок.</td></tr><tr class=""><td class="confluenceTd">HashAggOnLargeTable</td><td class="confluenceTd">Hash Aggregate на большой таблице (PlanRows={0}) может вызвать значительное использование памяти или запись во временные файлы.</td><td class="confluenceTd">Увеличьте work_mem или предварительно сократите набор данных (фильтрация/CTE).</td></tr><tr class=""><td class="confluenceTd">FunctionScan</td><td class="confluenceTd">Вызов Function Scan по '{0}' может быть медленным из-за отсутствия индексов и оптимизации функций.</td><td class="confluenceTd">Перепишите функцию так, чтобы она была IMMUTABLE/STABLE, либо материализуйте данные в таблице.</td></tr><tr class=""><td class="confluenceTd">MaterializeNode</td><td class="confluenceTd">Узел Materialize создаёт временные копии данных; если они не нужны повторно, это приводит к избыточным затратам памяти.</td><td class="confluenceTd">Удалите избыточный Materialize или замените его на временные таблицы/CTE.</td></tr><tr class=""><td class="confluenceTd">UnexpectedParallelism</td><td class="confluenceTd">Узел '{0}' исполняется параллельно (loops={1}), хотя не предназначен для этого. Возможны накладные расходы без выигрыша в скорости.</td><td class="confluenceTd">Проверьте parallel_setup_cost/parallel_tuple_cost и убедитесь, что узлы действительно parallel-safe.</td></tr><tr class=""><td class="confluenceTd">CardinalityMismatch</td><td class="confluenceTd">Кардинальное несоответствие: оценка планировщика сильно отличается от фактического числа строк.</td><td class="confluenceTd">Обновите статистику (ANALYZE), настройте default_statistics_target или создайте многоколонные статистики.</td></tr><tr class=""><td class="confluenceTd">BitmapHeapOverfetch</td><td class="confluenceTd">Bitmap Heap Scan по таблице '{0}' возвращает гораздо больше строк, чем предполагалось Bitmap Index Scan — возможна низкая селективность индекса.</td><td class="confluenceTd">Создайте более селективный индекс или добавьте INCLUDE колонки, чтобы сократить лишние чтения.</td></tr><tr class=""><td class="confluenceTd">HashSpillBatches</td><td class="confluenceTd">Hash оператор использует несколько батчей (Batches &gt; 1), что указывает на нехватку памяти и запись промежуточных данных на диск.</td><td class="confluenceTd">Увеличьте work_mem или уменьшите объём данных во входном потоке.</td></tr><tr class=""><td class="confluenceTd">HashSpillDisk</td><td class="confluenceTd">Hash оператор выполняет запись данных на диск из-за переполнения памяти.</td><td class="confluenceTd">Поднимите work_mem или используйте Merge Join вместо Hash Join.</td></tr><tr class=""><td class="confluenceTd">HashSpillTempFiles</td><td class="confluenceTd">Hash оператор/Hash Join пишет временные файлы на диск (TempWritten) — явный индикатор спиллов.</td><td class="confluenceTd">Повысьте work_mem, уменьшите количество обрабатываемых строк, либо используйте предагрегацию.</td></tr><tr class=""><td class="confluenceTd">IndexFilterMismatch</td><td class="confluenceTd">Index Scan/Bitmap Heap Scan использует фильтр, который не покрывается Index Cond — часть работы выполняется без индекса.</td><td class="confluenceTd">Создайте индекс с выражением или добавьте недостающие колонки в INCLUDE.</td></tr><tr class=""><td class="confluenceTd">IndexOnlyHeapFetch</td><td class="confluenceTd">Index Only Scan требует heap fetch — видимость строк в visibility map неполная.</td><td class="confluenceTd">Выполните VACUUM ANALYZE; рассмотрите CLUSTER или BRIN-индексы для улучшения покрытия visibility map.</td></tr><tr class=""><td class="confluenceTd">NestedLoopHeavyInner</td><td class="confluenceTd">Nested Loop выполняет дорогостоящую внутреннюю операцию многократно, что сильно замедляет запрос.</td><td class="confluenceTd">Создайте индекс на колонках join-ключа или замените Nested Loop на Hash/Merge Join.</td></tr><tr class=""><td class="confluenceTd">Parallelism</td><td class="confluenceTd">Запланированы параллельные воркеры, но они не запущены. Возможные причины: функции не parallel-safe, настройки сервера или параметры запроса.</td><td class="confluenceTd">Проверьте настройки max_parallel_workers, max_parallel_workers_per_gather и parallel_setup_cost.</td></tr><tr class=""><td class="confluenceTd">SeqScanFractionRemoved</td><td class="confluenceTd">Seq Scan по таблице '{0}' отбрасывает большую часть строк ({1}), что указывает на неэффективное чтение лишних данных.</td><td class="confluenceTd">Создайте частичный индекс по условию WHERE или рассмотрите денормализацию/предагрегацию.</td></tr><tr class=""><td class="confluenceTd">SeqScanIOHeave</td><td class="confluenceTd">Seq Scan по таблице '{0}' выполняет большое количество операций ввода-вывода (IO).</td><td class="confluenceTd">Создайте индексы по фильтрам и пересмотрите JOIN/WHERE.</td></tr><tr class=""><td class="confluenceTd">SortExternal</td><td class="confluenceTd">Сортировка выполняется с использованием внешней памяти — вероятен spill на диск.</td><td class="confluenceTd">Увеличьте work_mem или создайте индекс по колонкам ORDER BY.</td></tr><tr class=""><td class="confluenceTd">SortExternalTempFile</td><td class="confluenceTd">Сортировка использует диск (Sort Space Type=Disk) — данные не помещаются в память.</td><td class="confluenceTd">Увеличьте work_mem; оптимизируйте сортируемый набор (LIMIT, предфильтрация).</td></tr><tr class=""><td class="confluenceTd">SortExternalTempWritten</td><td class="confluenceTd">Сортировка записывает временные блоки на диск (TempWritten &gt; 0).</td><td class="confluenceTd">Оптимизируйте ORDER BY, создайте индекс или повысьте work_mem.</td></tr><tr class=""><td class="confluenceTd">TempFileSortSpill</td><td class="confluenceTd">Узел создаёт временные файлы для сортировок/хешей — это спиллы на диск.</td><td class="confluenceTd">Поднимите work_mem и уменьшите размер сортировок/хешей.</td></tr><tr class=""><td class="confluenceTd">HighBufferReads</td><td class="confluenceTd">Узел '{0}' по таблице '{1}' выполняет чрезмерное количество чтений буферов ({2} блоков).</td><td class="confluenceTd">Создайте индексы и фильтры для уменьшения числа читаемых блоков.</td></tr><tr class=""><td class="confluenceTd">LargeNumberOfLoops</td><td class="confluenceTd">Узел '{0}' по таблице '{1}' выполняется {2} раз (loops) — возможна неэффективная стратегия соединений.</td><td class="confluenceTd">Избегайте многократных Nested Loop — используйте Hash/Merge Join или материализацию.</td></tr><tr class=""><td class="confluenceTd">RepeatedSeqScan</td><td class="confluenceTd">Несколько Seq Scan повторяются для таблиц: {0}. Это может быть результатом неудачной декомпозиции запроса.</td><td class="confluenceTd">Оптимизируйте запрос с помощью CTE/подзапросов или кэширования промежуточных результатов.</td></tr><tr class=""><td class="confluenceTd">IndexOnlyScanButBitmap</td><td class="confluenceTd">Index Only Scan по таблице '{0}' вынужденно использует Bitmap Heap Scan, что говорит о нехватке покрывающего индекса.</td><td class="confluenceTd">Добавьте недостающие колонки в индекс, чтобы сделать его полностью покрывающим.</td></tr><tr class=""><td class="confluenceTd">HashJoinWithSkew</td><td class="confluenceTd">Hash Join испытывает дисбаланс данных (ratio {0}x), что снижает эффективность распараллеливания.</td><td class="confluenceTd">Используйте parallel hash join, перераспределение данных или настройку random_page_cost для снижения дисбаланса.</td></tr><tr class=""><td class="confluenceTd">ParallelSeqScanIneffective</td><td class="confluenceTd">Parallel Seq Scan по таблице '{0}' оказался неэффективным (ActualLoops={1}).</td><td class="confluenceTd">Снизьте parallel_setup_cost или настройте parallel_workers для адекватного распараллеливания.</td></tr><tr class=""><td class="confluenceTd">SortSpillToDisk</td><td class="confluenceTd">Sort узел пишет данные во временные файлы (spill) — TempWritten={0}.</td><td class="confluenceTd">Создайте индекс под ORDER BY или увеличьте work_mem.</td></tr><tr class=""><td class="confluenceTd">ExcessiveTempFiles</td><td class="confluenceTd">Узел '{0}' создает чрезмерное количество временных файлов (TempRead+TempWritten={1}).</td><td class="confluenceTd">Оптимизируйте запрос или увеличьте work_mem, чтобы сократить создание временных файлов.</td></tr><tr class=""><td class="confluenceTd">FunctionInWherePerformance</td><td class="confluenceTd">Функция в WHERE для таблицы '{0}' делает условие неиндексируемым.</td><td class="confluenceTd">Перепишите условие так, чтобы использовать индекс (например, вычисляемое поле).</td></tr><tr class=""><td class="confluenceTd">LeadingWildcardLike</td><td class="confluenceTd">Условие LIKE с ведущим '%' по таблице '{0}' исключает использование индексов.</td><td class="confluenceTd">Используйте trigram-индексы (pg_trgm) или полнотекстовый поиск вместо LIKE с ведущим '%'.</td></tr><tr class=""><td class="confluenceTd">MissingStatistics</td><td class="confluenceTd">Таблица '{0}' имеет неточные статистики: планировщик неверно оценивает число строк.</td><td class="confluenceTd">Выполните ANALYZE и настройте default_statistics_target для улучшения оценок.</td></tr><tr class=""><td class="confluenceTd">CorrelatedSubqueryExec</td><td class="confluenceTd">Коррелированный подзапрос выполняется {0} раз, что приводит к многократным обращениям к данным.</td><td class="confluenceTd">Перепишите подзапрос на JOIN или CTE для устранения множественных вызовов.</td></tr><tr class=""><td class="confluenceTd">SlowStartupTime</td><td class="confluenceTd">Узел '{0}' имеет длительное стартовое время ({1} мс), что замедляет выдачу первых результатов.</td><td class="confluenceTd">Оптимизируйте план — используйте индексы или материализованные представления для ускорения старта.</td></tr><tr class=""><td class="confluenceTd">ActualVsEstimatedLargeDiff</td><td class="confluenceTd">Большое расхождение между фактическим и оценочным числом строк (Actual/Plan={0}).</td><td class="confluenceTd">Обновите статистику и проверьте селективность предикатов.</td></tr><tr class=""><td class="confluenceTd">FilterAfterAggregate</td><td class="confluenceTd">Фильтрация выполняется после агрегирования на узле '{0}', что увеличивает нагрузку.</td><td class="confluenceTd">Перенесите фильтр в WHERE/HAVING до агрегирования.</td></tr><tr class=""><td class="confluenceTd">WorkMemExceededEstimate</td><td class="confluenceTd">Узел '{0}' пишет временные файлы ({1}), что говорит о превышении work_mem.</td><td class="confluenceTd">Увеличьте work_mem или перепишите запрос для снижения объема промежуточных данных.</td></tr><tr class=""><td class="confluenceTd">LargeAggregateMemory</td><td class="confluenceTd">Агрегатный узел '{0}' потребляет много памяти ({1} MB).</td><td class="confluenceTd">Сократите набор входных строк перед агрегацией или увеличьте work_mem.</td></tr><tr class=""><td class="confluenceTd">SortMethodExternal</td><td class="confluenceTd">Sort узел '{0}' использует внешний метод сортировки (Sort Method={1}), что указывает на spill.</td><td class="confluenceTd">Увеличьте work_mem или уменьшите сортируемый набор (LIMIT, предагрегация).</td></tr><tr class=""><td class="confluenceTd">BitmapIndexScanOnSmallTable</td><td class="confluenceTd">Bitmap Index Scan по маленькой таблице '{0}' (PlanRows={1}) может быть избыточным.</td><td class="confluenceTd">Используйте Seq Scan вместо Bitmap Index Scan — он будет быстрее на малых таблицах.</td></tr><tr class=""><td class="confluenceTd">IndexScanWithFilterOnNonIndexedCol</td><td class="confluenceTd">Index Scan использует фильтр '{0}', не покрытый индексом.</td><td class="confluenceTd">Добавьте индекс по фильтруемой колонке.</td></tr><tr class=""><td class="confluenceTd">SeqScanOnRecentlyUpdatedTable</td><td class="confluenceTd">Seq Scan по недавно обновлённой таблице '{0}' (updates={1}) может игнорировать индексы из-за неактуальных статистик.</td><td class="confluenceTd">Выполните VACUUM ANALYZE или создайте индекс по актуальным фильтрам.</td></tr><tr class=""><td class="confluenceTd">SeqScanWithHighTempWrites</td><td class="confluenceTd">Seq Scan по таблице '{0}' создаёт большое количество временных файлов ({1}).</td><td class="confluenceTd">Увеличьте work_mem и оптимизируйте фильтры для снижения записи во временные файлы.</td></tr><tr class=""><td class="confluenceTd">IndexScanButBitmapRecheck</td><td class="confluenceTd">Index Scan по таблице '{0}' требует Bitmap Heap Recheck — возможно, индекс не полностью оптимален.</td><td class="confluenceTd">Создайте более точный индекс, чтобы исключить recheck.</td></tr><tr class=""><td class="confluenceTd">ParallelWorkersTooMany</td><td class="confluenceTd">Узел '{0}' запускает слишком много воркеров (Launched={1}, Planned={2}), что приводит к накладным расходам.</td><td class="confluenceTd">Снизьте количество параллельных воркеров — настройте max_parallel_workers_per_gather.</td></tr><tr class=""><td class="confluenceTd">HashAggWithoutHashableKey</td><td class="confluenceTd">Hash Aggregate узел '{0}' использует ключ '{1}', неподходящий для хэширования.</td><td class="confluenceTd">Используйте Sort Aggregate или преобразуйте ключ в хэшируемый тип.</td></tr><tr class=""><td class="confluenceTd">CrossProductDetected</td><td class="confluenceTd">Nested Loop без условий соединения на узле '{0}' — это кросс-произведение, крайне неэффективное.</td><td class="confluenceTd">Добавьте условия соединения (ON/USING), чтобы избежать кросс-произведения.</td></tr></tbody></table>